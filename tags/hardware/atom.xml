<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>altonimb.us - hardware</title>
    <subtitle>Website of Nick Brown</subtitle>
    <link rel="self" type="application/atom+xml" href="https://altonimb.us/tags/hardware/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://altonimb.us"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-07-18T00:00:00+00:00</updated>
    <id>https://altonimb.us/tags/hardware/atom.xml</id>
    <entry xml:lang="en">
        <title>NONIK0 Project Writeup</title>
        <published>2025-07-18T00:00:00+00:00</published>
        <updated>2025-07-18T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              nonik0
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://altonimb.us/nonik0/"/>
        <id>https://altonimb.us/nonik0/</id>
        
        <content type="html" xml:base="https://altonimb.us/nonik0/">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h1&gt;
&lt;p&gt;After getting my first working Rust &quot;tech demo&quot; animation running on Light Rail, I found myself wanting to dive deeper into embedded Rust development while also just wanting a mental break from working on my earlier Light Rail project. I decided that I would work on another more simple project and continue experimenting and learning Rust while doing so. The idea for this project came together fairly quickly because several factors aligned at once. First, I had been itching to try out these little retro dot matrix displays (HCMS-29XX) in my next project. I had originally discovered them while looking around for Light Rail components. Second, I wanted to design an even lower power battery device compared to Light Rail, where it could run off a single CR2032. The &lt;a href=&quot;https:&#x2F;&#x2F;gitlab.com&#x2F;bradanlane&#x2F;avrcoding101&quot;&gt;ACK1 hardware&lt;&#x2F;a&gt; was a big design inspiration here as a minimalist design reference. Finally, I wanted to try OSHpark&#x27;s AfterDark service. The matte look and the color scheme of the PCBs really appealed to me, so I wanted to try to use it as part of my design.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;hardware-design&quot;&gt;Hardware Design&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;prototype-and-concept&quot;&gt;Prototype and Concept&lt;&#x2F;h2&gt;
&lt;p&gt;
&lt;a href=&quot;&#x2F;nonik0&#x2F;prototype.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;prototype.5e4411bf54cf732d.jpg&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;float:right;;
           margin:0.5rem;&quot;
        alt=&quot;Prototype using Adafruit Feather 32u4 Proto&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;

&lt;a href=&quot;&#x2F;nonik0&#x2F;prototype_back.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;prototype_back.13ce24a588c57727.jpg&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;float:right;;
           margin:0.5rem;&quot;
        alt=&quot;Prototype using Adafruit Feather 32u4 Proto, showing back of board&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Before I had started in earnest with this project, I had made a simple prototype using an Adafruit Feather 32u4 Proto and two 4-char HCMS-29XX displays. It was helpful for a reasonable approximation of what I was envisioning in my head, which was to design a small wearable battery-powered device to showcase the dot matrix display (and then learn some more Rust). I decided early on to base the design around ATtiny1604. I selected the ATtiny1604 because it had the right number of pins for what I needed and it supported UPDI programming (1 pin programming! 3 with power and ground). For the PCB layout, I wanted to embrace the visible trace aspect of the AfterDark finish by using thick traces arranged in a maze-like motif, using right angles and rigid spacing throughout.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pcb-layout&quot;&gt;PCB Layout&lt;&#x2F;h2&gt;
&lt;p&gt;When I began layout, I first wanted to establish the overall dimensions of the PCB. I started from the Adafruit Feather spec size, whose height roughly matches the footprint of a standard CR2032 battery holder, including the solder contacts. However, rather than orienting the battery holder this way on my board, I rotated it 90°, which let me shrink the PCB height to just a small margin over the width of a CR2032 (32mm). I also extended the length of the PCB a bit so I could fit a second battery holder on the back, which could hold either a spare battery or a magnet (so the device could be attached clothing with another magnet, or to a ferromagnetic surface).&lt;&#x2F;p&gt;
&lt;div class=&quot;justify-center not-prose flex flex-wrap gap-2&quot;&gt;
  
&lt;a href=&quot;&#x2F;nonik0&#x2F;layout_test_2.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;layout_test_2.6c85dd6789d05441.jpg&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;float:right;;
           margin:0.5rem;&quot;
        alt=&quot;Trying out component layout on sketch of board outline&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
  
&lt;a href=&quot;&#x2F;nonik0&#x2F;layout_test_3.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;layout_test_3.9784a21df948f94c.jpg&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;float:right;;
           margin:0.5rem;&quot;
        alt=&quot;Trying out component layout on sketch of board outline&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
  
&lt;a href=&quot;&#x2F;nonik0&#x2F;layout_test_1.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;layout_test_1.9d617e99c92b3789.jpg&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;float:right;;
           margin:0.5rem;&quot;
        alt=&quot;Trying out component layout on sketch of board outline&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;With the board dimensions set, I drew them up on a sketch pad and came up with a layout I liked after a few minutes. The dot matrix display was centered and to the left of the ATtiny and two buttons. I found a tiny little 2mm buzzer that was able to fit in nicely just above the display. I placed a small LED below the display and connected to the display&#x27;s data out pin to function as display update indicator. On the back of the board, in addition to the two battery holders, I added a power switch, a JST-SH 4 pin connector, and the UPDI contacts. Then, I laid out the traces in accordance with the maze-like aesthetic I had in mind—thick, visible traces that used only right angles, meandering a bit to fill the available space on the board. I also added test points on the front to help with this as well. Towards the end, I decided (and managed) to cram in some additional circuitry in between the two battery holders on the back. If included when assembled, it would give the option of boosting the LED supply voltage to 5V. This would let me test the displays with different LED supply voltages (technically the HCMS-29XX datasheet states a required 5V for the LEDs but in my usage&#x2F;testing up to that point seemed fine at ~3.3V). Then, I ordered the boards from OSHPark.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hardware-testing&quot;&gt;Hardware Testing&lt;&#x2F;h2&gt;
&lt;p&gt;After a few weeks I got the boards, and I was eager to test them with some test C++ code before I started with Rust support. After assembling one with my mini hot plate, I was very happy when I was able to clip my UPDI programmer to the board and flash the ATtiny within minutes. However, after the successful flashing, nothing happened. For a bit I had some initial befuddlement wondering how flashing was working flawlessly any code I uploaded was not. I channeled my inner AVR guru and the word &quot;fuses&quot; materialized in my mind. After a quick lookup, I was able to update the PlatformIO configuration to write the proper fuse settings when flashing (and the fuse settings are automatically determined, nice!). Then after another flash and seeing the fuses written in the shell output, I then looked down on my desk to see a beautiful, orange-hued message shining on the HCMS display—&quot;&lt;strong style=&quot;color: orange;&quot;&gt;  test  &lt;&#x2F;strong&gt;&quot;! I then took a breath for the first time since I initially flashed the hardware.&lt;&#x2F;p&gt;

&lt;a href=&quot;&#x2F;nonik0&#x2F;floating_circuit.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;floating_circuit.d47417e073c8d776.jpg&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;float:right;;
           margin:0.5rem;&quot;
        alt=&quot;Makeshift piezo driver circuit on back of board&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
&lt;p&gt;With the biggest mental hurdle out of the way (a functional board), I moved onto testing the hardware. Testing with and without the optional 5V boost circuit showed it wasn&#x27;t worth including—no meaningful brightness improvement, an audible switching noise, and the ATtiny browned out on CR2032 batteries. In fact, I was able to get a decent brightness from the display using some &quot;dead&quot; CR2032s. The buzzer was audible but quiet, and dropping the resistor to drive it directly from a pin made it slightly less so. I also jury-rigged a driver circuit with a transistor on the back of the board to (properly) drive the buzzer, and with that addition the buzzer volume was much more audible. I was curious if I would need the usual flyback diode for the inductive kickback for such a small little buzzer. Given that I recently acquired a decent oscilloscope, I was happy to mess around and find out. I was surprised to see that the kickback from the buzzer on the collector when the transistor closed was over 50V! With the diode in place, the spike was reduced to only a couple volts, so a 25x reduction! Keeping the diode.&lt;&#x2F;p&gt;
&lt;div class=&quot;justify-center not-prose flex flex-wrap gap-2&quot;&gt;
  
&lt;a href=&quot;&#x2F;nonik0&#x2F;without_diode.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;without_diode.009d9af3db316113.png&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;float:left;;
           margin:0.5rem;&quot;
        alt=&quot;Without diode, large voltage spikes seen on transistor collector&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
  
&lt;a href=&quot;&#x2F;nonik0&#x2F;with_diode.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;with_diode.fb50d605892927e9.png&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;float:left;;
           margin:0.5rem;&quot;
        alt=&quot;With diode, voltage swings are minimal&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
&lt;&#x2F;div&gt;
&lt;br&#x2F;&gt;
&lt;h1 id=&quot;rust-support-and-firmware&quot;&gt;Rust Support and Firmware&lt;&#x2F;h1&gt;
&lt;p&gt;With the hardware validated, I could start digging into the Rusty firmware stuff. However, getting any Rust to run on the ATtiny1604 required laying some ground work first. The most popular Rust framework for AVR microcontrollers, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Rahix&#x2F;avr-hal&quot;&gt;avr-hal&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Rahix&#x2F;avr-device&quot;&gt;avr-device&lt;&#x2F;a&gt;, did not yet support the ATtiny1604. Then once this support was in place and supported the required hardware peripherals for this project. I would need a Rust driver for the HCMS-29XX display, as well as other primitives I will get into.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;basic-rust-support&quot;&gt;Basic Rust Support&lt;&#x2F;h2&gt;
&lt;p&gt;Adding the &quot;Rust support&quot; to the ATtiny1604 came in a couple steps. First, I added support to avr-device for the ATtiny1604, along with the rest of the ATtiny X04 family. The avr-device crate is essentially a wrapper for svd2rust, which generates the register access abstractions for supported AVR chips using &lt;a href=&quot;https:&#x2F;&#x2F;arm-software.github.io&#x2F;CMSIS_5&#x2F;SVD&#x2F;html&#x2F;svd_Format_pg.html&quot;&gt;svd files&lt;&#x2F;a&gt;. There&#x27;s actually not much interesting to say about this step. I just followed the README instructions in the repo and looked at work from similar PRs. I had to grab some metadata files from Microchip and update various includes and metadata type stuff. The second step for Rust support was adding support in avr-hal, which is the crate that provides the Arduino-like abstractions for AVR chips. The most noteworthy aspect of updating avr-hal was that all of the currently supported chips with avr-hal are based on two AVR architectures—tinyAVR and megaAVR. However, the ATtiny1604 is based on the newer XMEGA AVR architecture. This meant a whole additional crate would need to be added to be able to support the ATtiny1604 or any other XMEGA chip. Luckily, after digging into PRs in the avr-hal repo, I found a two-year old, incomplete PR that already had a lot of the work to add basic support for ATtiny404 with basic GPIO. With a rebase to the current state of the avr-hal repo and a few necessary tweaks and adding support for the rest of ATtiny X04 family, I was able to get a simple test project building that was targetting ATtiny1604 using my dispaly driver. Then I used avrdude to upload the compiled binary file and...it worked right out of the gate! This sort of thing feels like a lottery ticket when working with C++. Another testament to the Rust compiler and its runtime assurances.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;basic-peripheral-support&quot;&gt;Basic Peripheral Support&lt;&#x2F;h2&gt;
&lt;p&gt;With the basic Rust support out the of way, I started working on cleaning up some more of the core functionality I would need. Porting over my tone and random implementation from Light Rail went fairly smooth. The tone implementation required more changes to get working considering the differences the megaAVR and XMEGA architectures and how the timers and interrupts are managed. I referenced the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SpenceKonde&#x2F;megaTinyCore&#x2F;blob&#x2F;0999bf2553cdd48fd1f0730e590768e98e7d870a&#x2F;megaavr&#x2F;cores&#x2F;megatinycore&#x2F;Tone.cpp&quot;&gt;tone implementation&lt;&#x2F;a&gt; in SpencerKonde&#x27;s MegaTinyCore for some changes. I also used the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SpenceKonde&#x2F;megaTinyCore&#x2F;blob&#x2F;0999bf2553cdd48fd1f0730e590768e98e7d870a&#x2F;megaavr&#x2F;libraries&#x2F;EEPROM&#x2F;src&#x2F;EEPROM.h#L74&quot;&gt;EEPROM implementation&lt;&#x2F;a&gt; as a reference as well and was able to add it cleanly to the existing shared EEPROM traits in avr-hal. The implementation uses inline AVR assembly and is similar to the assembly code in MegaTinyCore with a few adjustments to the registers used. This was my first time using inline assembly in Rust and I found it to be relatively painless. What was painful, however, was attempting to get the EEPROM implementation to work without the inline assembly and instead using avr-device&#x27;s register access. I tried a lot of different things to try to get the EEPROM to successfully write any data. The datasheet clearly says that specific instructions need to be done within 4 clock cycles of each other to work, so I am just assuming that the compiled code is bloat somewhere and the critical timing is not being met. It would explain why the MegaTinyCore implementation was in assembly. Decompiling the bin to investigate the assembly and pinpoint the issue is something I&#x27;d like to do in the future, but with the working assembly implementation I could wrap up and move on.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;control-flow-design&quot;&gt;Control Flow Design&lt;&#x2F;h2&gt;
&lt;p&gt;With all the aforementioned Rust prereqs out of the way, I started on the core firmware logic. Thanks to my earlier reviews of other Rust project writeups and source code, I had a good idea of how I envisioned the core loop would operate. From a feature-standpoint, I wanted to be able to configure and show a name, adjust the display&#x27;s settings, and also show an animation. I would encapsulate these features into several named modes with a simple menu interface to navigate and change the currently active mode. So the control flow would be structurally simple: have a main loop that each cycle will process input events, process them within the context of the main loop, then call an update function for the active mode. Each mode would implement this function and be able to handle its own specific logic, with passed references for shared access to state and peripherals. In Rust pseudocode that roughly looks like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; process input events, if any (e.g. button press&#x2F;hold&#x2F;release)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; event &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;process_input&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; process event in &amp;quot;shared&amp;quot; context (e.g. handle tone for button presses, switching modes)
&lt;&#x2F;span&gt;&lt;span&gt;    mode &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;process_event&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;event&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; call update for active mode mode, passing event, state, and peripherals
&lt;&#x2F;span&gt;&lt;span&gt;    mode&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;update&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;event&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;, &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;state&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;, &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;peripherals&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This approach is deliberately simple and barebones — we&#x27;re a far cry from having access to fancier embedded async frameworks like &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;embassy&quot;&gt;embassy&lt;&#x2F;a&gt;, just a single main loop. So every cycle of the main loop, the input would be processed and potentially emit an event (e.g. enum with discriminants like LeftButtonPressed and RightButtonReleased). Then, the current mode would have its specific update function called, passing the event, if any, along with a shared state and peripherals struct by reference. This pattern of passing around references works really well with Rust&#x27;s borrow checker. The display object, as part of a shared peripherals struct, gets passed to the active mode and can be used to update the display, and the mode never takes &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-00-understanding-ownership.html&quot;&gt;ownership&lt;&#x2F;a&gt; of the display object. In Rust, this is very clean approach relative to other options for sharing access to a hardware peripheral or shared state that would be fairly common in other languages, like using a static&#x2F;global variable. So many design patterns that would be relatively simple in C++, like the static global variable, in Rust become a struggle with the compiler. By design Rust makes certain classes of traditional bugs, like &lt;a href=&quot;https:&#x2F;&#x2F;redixhumayun.github.io&#x2F;concurrency&#x2F;2024&#x2F;05&#x2F;17&#x2F;data-race-vs-race-condition.html&quot;&gt;data races&lt;&#x2F;a&gt; with mutable statics in this case specifically, into compile time errors. So if you are attempting an &quot;unsafe&quot; pattern in Rust and going against the grain, the compiler will let you know. With the mutable static case in Rust, you&#x27;ll need use a sync primitive or two (or judicious use of &lt;code&gt;unsafe&lt;&#x2F;code&gt; itself). Even with simple chips like the ATtiny1604, data races with a &quot;single&quot; core&#x2F;thread&#x2F;loop are possible because of interrupts. This is how the tones are generated and play asyncronously with the code. My tone implementation makes use of sync primitives for safe shared access of the tone state between the interrupt handler and the main loop. What I have learned is that if I&#x27;m struggling or working a bit extra to get a design pattern to work (i.e. compile) in Rust, it&#x27;s probably for a good reason. Rust pushes you toward patterns that are generally much less prone to specific classes bugs that can be caught before runtime, specifically enabled through the design of the language itself. I like it. That&#x27;s a very different experience from C&#x2F;C++ land, where you can throw cast data however you please and pass around pointers to anywhere fairly willy-nilly.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dynamic-dispatch&quot;&gt;Dynamic Dispatch&lt;&#x2F;h3&gt;
&lt;p&gt;Once I had the general control flow in mind, I needed to figure out how to actually implement the modes. In most languages&#x2F;environments, this would be straightforward - you&#x27;d define an interface that all modes implement, then store a reference to whichever mode is currently active, dereference and call interface. There is corresponding concept to interfaces in Rust with &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch18-02-trait-objects.html&quot;&gt;trait objects&lt;&#x2F;a&gt;. However, we are not in a standard environment, we are in &lt;a href=&quot;https:&#x2F;&#x2F;docs.rust-embedded.org&#x2F;book&#x2F;intro&#x2F;no-std.html&quot;&gt;&lt;code&gt;no_std&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. That means there is no stack overflow protection (foreshadowing!) nor a heap for dynamic memory. Objects that would normally live on the heap need static or stack-allocated alternatives instead. C++ has been around a while so there&#x27;s plenty of options available for working in heapless environments but Rust is still fairly nascent in embedded so both the options of libraries (crates) as well as shared developer knowledge from places like SO and articles is much thinner (and consequently the amount of training data for LLMs). I searched and LLM-prompted for heapless trait object and got a link&#x2F;reference to &lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;68581448&#x2F;is-there-a-heapless-trait-object&quot;&gt;this stackoverflow question&lt;&#x2F;a&gt; from both, so I just went with it.&lt;&#x2F;p&gt;
&lt;p&gt;As the SO question mentions, using references instead of &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;Box&lt;&#x2F;a&gt; types (heap-allocated) adds &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;scope&#x2F;lifetime.html&quot;&gt;lifetimes&lt;&#x2F;a&gt; and additional complexity. Our friend the borrow checker needs to ensure that the lifetime of the references will outlive the objects that own them. Using a Mode trait to define the signature for the update fucntion, my initial solution ended up using an array of static mutable references for Mode trait objects with static lifetimes, or as Rust:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;[&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;static mut&lt;&#x2F;span&gt;&lt;span&gt; dyn Mode&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;; &lt;&#x2F;span&gt;&lt;span&gt;NUM_MODES&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It honestly took me a lot of trial and error and asking AI tools with help to better understand lifetimes before I got some traction with the compiler and the number of errors started going down with each change I made. Writing this, I definitely have a better handle on lifetimes now and I have learned that when using them they tend to spread through Rust code like a virus, infecting everything they interact with. If you find yourself using them extensively, you should be able to articulate why - otherwise it usually means you haven&#x27;t explored simpler design patterns enough. At the time I was happy enough with my reason, the modes themselves were statically allocated, and so they maintained their state in between mode switches. However, as I implemented more modes, this approach became problematic due to memory constraints - which I&#x27;ll cover next. As for the modes themselves, implementing them was mostly straightforward without much to comment on, you can refer to the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nonik0&#x2F;NONIK0&#x2F;blob&#x2F;main&#x2F;README.md&quot;&gt;documentation&lt;&#x2F;a&gt; for more details on them.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dealing-with-constraints&quot;&gt;Dealing with Constraints&lt;&#x2F;h2&gt;
&lt;p&gt;The static array approach I described worked initially, but as I implemented more modes (as I fell prey to scope creep) and started consuming more resources on the chip, I started hitting the ATtiny1604&#x27;s memory constraints in unexpected ways. While I was pretty happy when I was able to get a custom panic routine working early on in development, where I could output debug panic data on the display, I was disappointed when I found myself running out of flash soon after and I couldn&#x27;t compile all the modes I was working on. Using cargo-bloat, I was able to see how the panic handler was using ~6KB out of the total 16KB of flash! I opted to initially work around this constraint to focus on finishin the modes by adding Rust features. Then I could conditionally compile out the panic handler and specific modes as needed. I also found other optimizations such as strategically avoiding use of specific functions in crates like heapless to further reduce the flash size by several KB.&lt;&#x2F;p&gt;
&lt;p&gt;However, as I was wrapping up the last few modes, I started to see signs of memory corruption when testing the firmware where it would become unresponsive and&#x2F;or the display would output garbage. At first, because I had just been working on changes for reducing the flash usage, I assumed the issue was a bug in my recent updates. I had been shifting from using large match statements for display output to indexing into const arrays for string data. I thought that since I had experimenting compiler settings and building in release to save space in the flash, that could be the culprit. However, after some investigation, that turned out not to be the case. The biggest clue was the &quot;heisenbug&quot; nature of the problem. When I removed modes to make room for the panic handler, the memory corruption disappeared. But as soon as I added the modes back, the corruption returned. The act of trying to debug the issue was actually fixing it.&lt;&#x2F;p&gt;
&lt;p&gt;Given the heisenbug behavior, I then was able to turn my attention to a different constraint entirely—SRAM. The ATtiny1604 has only 1KB of SRAM, and since my dispatch solution was holding all mode data statically, that was probably cutting directly into the stack size. Using the avr-size profiling tool, I took a look at the size of my firmware&#x27;s memory segments:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;   text    data     bss     dec     hex filename
&lt;&#x2F;span&gt;&lt;span&gt;  16057     298     351   16706    4142 target\..\NONIK0.elf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The baseline&#x2F;at boot SRAM usage was 298+351=649 bytes, which left only 1024-649=375 bytes for the entire stack. I had a pretty good smoking gun at this point.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;an-improved-dynamic-dispatch&quot;&gt;An Improved Dynamic Dispatch&lt;&#x2F;h3&gt;
&lt;p&gt;With the SRAM issue diagnosed, I knew needed a different approach but didn&#x27;t immediately tackle it. Instead, I was able to get the firmware to a stable point without too much refactoring by simply compiling out one of the modes that used more SRAM. Around this time, I took a break from this project to pivot back to Light Rail. However, it wasn&#x27;t long before I had to revisit the same dynamic dispatch problem in Light Rail for its different gameplay modes. I instinctively recoiled at the notion of just reusing the static array dispatch since I already knew the con of increased SRAM usage was pretty bad on a chip already constrained by SRAM and I also just wanted to keep trying different things.&lt;&#x2F;p&gt;
&lt;p&gt;So the solution I discovered in Light Rail, and immediately ported back to NONIK0, is called enum dispatch. With enum dispatch, the mode trait objects are wrapped within the discriminants of an enum (a neat Rust feature). What this improves over trait objects being held in a static array is that now there is just a single instance of the enum for the currently active mode held in SRAM, not all of them! The actual size allocated in memory will be the size of the largest enum discriminant with some overhead. There were some initial hiccups when the flash size ballooned after intially implementing this approach. After taking a look at the binary with cargo-bloat, I saw how the dispatched &lt;strong&gt;update()&lt;&#x2F;strong&gt; functions were being duplicated in the flash by the compiler, which was unfortunate give these were large functions. A light application of &lt;strong&gt;#[inline(never)]&lt;&#x2F;strong&gt; on the dispatch functions fixed the bloat instantly. With a working build using the new approach, I used avr-size once again to profile the memory segments:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;   text    data     bss     dec     hex filename
&lt;&#x2F;span&gt;&lt;span&gt;  15669     234      19   15922    3e32 target\..\NONIK0.elf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Wow. The new baseline SRAM usage was now 234+19=253 bytes, down from 649 bytes. With only 1KB SRAM total, that made a massive difference. Manual testing confirmed that all was well and I was not able to repro the memory issue again. While I did like how the array approach kept each mode&#x27;s state intact between switches, clearly given the constraints present, enum dispatch was definitely the better solution to go with. I later found the &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;enum_dispatch&quot;&gt;enum_dispatch crate&lt;&#x2F;a&gt; that allowed me to remove the boilerplate dispatch function and have it be generated by the crate! And with that, I felt a reasonable degree of project completion.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion-and-next-steps&quot;&gt;Conclusion and Next Steps&lt;&#x2F;h1&gt;
&lt;p&gt;Overall, this project was a great success for me. I had fun doing it, as evidenced by all the unplanned modes I implemented (especially tinkering around with the ADC). But beyond that, I was able to take a break from Light Rail and continue to become more adept using Rust without simultaneously overburdening myself with thinking up gameplay ideas and such for Light Rail and struggling to implement them. I gained a lot more confidence working with Rust at a low level and it&#x27;s a unique feeling to know I was one of the first people to run any Rust code on this family of AVR chips! Having to deal with the memory constraints of the chip were frustrating at first but ultimately very valuable. The constraints forced me to explore outside the &quot;easy mode&quot; alternatives that exist in &lt;code&gt;std&lt;&#x2F;code&gt; Rust and instead pushed me to seek and try out more design patterns that I wouldn&#x27;t have discovered otherwise. On top of the valuable Rust experience, I now have a functional, wearable, battery-powered, fancy LED display nametag to finish out my vision from the beginning.&lt;&#x2F;p&gt;
&lt;p&gt;Having achieved the core project goals, there are a couple more things I&#x27;m looking forward to as a continuation of this project. One is contributing some of my work back to the Rust open-source community through more PRs like my latest in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Rahix&#x2F;avr-device&#x2F;pull&#x2F;182&quot;&gt;avr-device&lt;&#x2F;a&gt;. I also already have a new PCB revision ordered that fixes the I2C pin assignments for the JST connector and includes the buzzer driver circuit I managed to cram onto the back. I&#x27;m looking forward to adding I2C functionality and eventually implementing an I2C scanner&#x2F;tester mode.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Light Rail Project Writeup, Part 1</title>
        <published>2025-04-10T00:00:00+00:00</published>
        <updated>2025-04-28T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              nonik0
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://altonimb.us/light-rail/"/>
        <id>https://altonimb.us/light-rail/</id>
        
        <content type="html" xml:base="https://altonimb.us/light-rail/">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h1&gt;

&lt;a href=&quot;&#x2F;light-rail&#x2F;board_front_on.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;board_front_on.d979bb6f40146230.jpg&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;float:left;;
           margin:1rem;&quot;
        alt=&quot;Working prototype!&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
&lt;p&gt;This project started from the simple desire for me to come up with my own concept for a hardware badge, akin to the ones you&#x27;d see at places like &lt;a href=&quot;https:&#x2F;&#x2F;defcon.org&#x2F;&quot;&gt;DefCon&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;hackaday.com&#x2F;tag&#x2F;supercon&#x2F;&quot;&gt;SuperCon&lt;&#x2F;a&gt;. If you are not aware, hardware badges are generally thematic, bespoke development boards with included hardware&#x2F;peripherals that are easy to hack and modify. To me, the hardware badge is the perfect manifestation of the maker&#x2F;hacker culture. They embody the curiosity to experiment and try new things, the desire to always be learning and improving, and most importantly the willingness and desire to share your project with the community so others can be inspired, learn from, and subsequently build upon your work. This last facet is the most important to me because it&#x27;s the primary cog that drives the maker community. It is from this sense of sharing with community that really drove me really stop &quot;lurking&quot; and start putting my own projects out for others to see.&lt;&#x2F;p&gt;
&lt;p&gt;The process of getting my projects out into the public sphere at first was simply getting more organized and collecting my various existing project files into public Git repos. I definitely still have more work to do here! But in addition to sharing code and pictures, I also really value all of the project writeups I&#x27;ve read over the years from the multitude of other makers. I have really benefitted from those who have taken the time to both share their projects as well as composing their process into a helpful and informative writeup. So it is in that spirit that I decided to share my own experience developing this project with this writeup. Writing has never really been enjoyable for me, mostly because I feel so inefficient when I do. As a side benefit of pushing myself through this process, I am also hoping this writeup will serve as the basis for traning data for an LLM that could help me share even more in the future by writing in my own voice!&lt;&#x2F;p&gt;
&lt;br&#x2F;&gt;
&lt;h1 id=&quot;design-inspiration-and-concept&quot;&gt;Design Inspiration And Concept&lt;&#x2F;h1&gt;
&lt;p&gt;The overall design idea of Light Rail came together in my head unexpectedly, all at once. I was in bed, trying to wrangle my thoughts and fall asleep. I was struggling because my mental state was still buzzing with excitement after recently deciding to finally come up with an idea for my own hardware badge.&lt;&#x2F;p&gt;
&lt;p&gt;For months prior, I had been toying around with small projects, experimenting with different breakout boards for LED drivers, trying out all sorts of little ideas—fun animations for sensor data, a tunnel runner animation, a maze runner animation, a maze runner animation with enemy sentries, experimenting with RTOSes to see how many I2C displays I could smoothly animate, etc. Just scratching that itch for experimentation and the sake of trying things out. Then that night, I was looking at all of my flashy projects where I have them displayed in my office (a collection—not a hoard) when a thought hit me: &quot;All of these projects are running your code, but none of them are your hardware!&quot;&lt;&#x2F;p&gt;
&lt;p&gt;With that realization, I decided to think up and design my own unique take on a hardware badge. So there I was in bed, trying to sleep despite the random flurry of ideas that were popping into and out of my thoughts. I did eventually calm my mind enough to drift toward sleep. However, the calm in my head only lasted a few moments. The gears of my subconscious must have kept spinning because before I was able to fall asleep, in an instant, all of the chaotic swirling of all my earlier scattered thoughts came rushing back into my head. But then, surprisingly, the earlier chaos of ideas swiftly coalesced in my head with the precision, speed, and grace of a team of animal mechs assembling into Voltron.&lt;&#x2F;p&gt;
&lt;p&gt;It was a unique mental experience I won&#x27;t soon forget! It&#x27;s quite hard to describe, but I think I can manage to at least give a non-exhaustive list of the ideas&#x2F;inspirations that ultimately coalesced into what is now Light Rail:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;trains, in general&lt;&#x2F;li&gt;
&lt;li&gt;Lego trains (this is not my first train project! Also see my &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nonik0&#x2F;CardputerLegoTrainControl&quot;&gt;M5Cardputer firmware&lt;&#x2F;a&gt; for controlling Lego trains and switches)&lt;&#x2F;li&gt;
&lt;li&gt;my nephew who also loves trains&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;dinopoloclub.com&#x2F;games&#x2F;mini-metro&#x2F;&quot;&gt;Mini Metro&lt;&#x2F;a&gt;, a game with trains&lt;&#x2F;li&gt;
&lt;li&gt;PCB Convention Badges, especially &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Hack-a-Day&#x2F;2022-Supercon6-Badge-Tools&quot;&gt;Supercon 2022 badge&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tiger_Electronics&quot;&gt;TIGER Electronics&lt;&#x2F;a&gt; handheld LCD games&lt;&#x2F;li&gt;
&lt;li&gt;Adafruit LED backpacks, especially &lt;a href=&quot;https:&#x2F;&#x2F;www.adafruit.com&#x2F;product&#x2F;2946&quot;&gt;this one&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;

&lt;a href=&quot;&#x2F;light-rail&#x2F;sketch.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;sketch.aed273e76e3db483.jpg&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;float:right;;
           margin:0.5rem;&quot;
        alt=&quot;My first (and only) concept sketch&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
&lt;p&gt;OK, so what was the actual idea? It was a train game. The tracks would be represented as lines of LEDs, with silkscreen graphics, and the trains themselves would be contiguous sequences of lit LEDs moving along those tracks—each LED representing a single car in the train. Arranged alongside the tracks would be other LEDs that would represent the platforms. When lit, a platform would indicate cargo ready for pickup, which a passing train could collect from an adjacent track and deliver to another platform elsewhere. The train&#x27;s cargo could be visualized using bright LEDs for full cars and dim ones for empty cars. The track layout would include forks and crossings, each with a nearby push button to toggle or switch their state.&lt;&#x2F;p&gt;
&lt;p&gt;Later, I came up with the idea to also integrate the rest of the board&#x27;s components into the visual theme—I added silkscreen roads and parking spaces around the various rectangluar ICs and platform LEDs to give the appearance that they were buildings on a map.&lt;&#x2F;p&gt;
&lt;p&gt;As for the gameplay itself, I never really prioritized it—even now, as I write this. It’s always been the least important part of the project for me. The main reason is simple: it&#x27;s hard to know what will actually be fun without being able to playtest it. Instead, I focused on being thoughtful with the board design so that, once I had functional hardware in hand, the board itself would naturally inspire gameplay ideas. I wanted something flexible—something that would give me room to experiment and explore once I could see it in action. I just haven’t done that part yet. That’s for part two!&lt;&#x2F;p&gt;
&lt;br&#x2F;&gt;
&lt;h1 id=&quot;hardware-design&quot;&gt;Hardware Design&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;design-goals&quot;&gt;Design Goals&lt;&#x2F;h2&gt;
&lt;p&gt;As soon as the Light Rail idea hit me, I started right away. Like I mentioned earlier, I had been trying to fall asleep, but the moment the idea surfaced, I got up immediately and started chugging away at the initial schematic in KiCad. By the time I went back to bed, I had already finished the majority of what would become the final schematic!&lt;&#x2F;p&gt;
&lt;p&gt;Since that original burst of inspiration, the design hasn’t changed much. What did surprise me, though, was how the design process felt. From beginning to end, it was less about inventing things piece by piece and more about revealing something that was already in my head. That’s the best way I can describe it—it felt more like discovery than creation. Apparently, I had been designing it subconsciously for a while.&lt;&#x2F;p&gt;
&lt;p&gt;Even though I had a strong mental image from the start, I eventually found it incredibly valuable to distill all those swirling ideas into clear, articulated design goals. I didn’t do this early on. At first, I just held everything loosely in my head and followed the momentum of my excitement. But as I got further along—especially when I was trying to wrap things up—I started getting distracted by too many side ideas. Some of them were genuinely cool, but they strayed from the core concept.&lt;&#x2F;p&gt;
&lt;p&gt;My favorite example: I had recently picked up a few breakout boards for secure element chips and had been experimenting with them. That led to a new idea—what if I turned the project into a cutting-edge &quot;cash-in-a-puzzle-box&quot; gift? Like those plastic gift boxes where you need to solve a maze before you can get the money or card inside. The idea was that my board could function like a hardware wallet, using the secure element to store crypto keys. A parent could preload the wallet, lock it, and give it as a gift. The recipient would have to achieve some unlock condition—like a high score or solving a puzzle—before accessing the wallet. I still love this idea! But it wasn’t part of the original vision. And worse, it completely derailed my design progress for a few days until a few gentle epithets from my brother helped me realign.&lt;&#x2F;p&gt;
&lt;p&gt;So for me, the below design goals I outline were essential in trimming down the infinite possibility space into something more focused and manageable. At the core, it&#x27;s just a mental trick I needed to use to stop my brain from being the enemy. The design goals helped me keep my overreaching curiousity tendencies in check and prioritize decisions that aligned with the original vision—not just flashy add-ons or nice-to-haves.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;no-matrix&quot;&gt;No Matrix.&lt;&#x2F;h3&gt;
&lt;p&gt;The board would not use an LED matrix—or anything resembling a traditional rectilinear layout. This was my very first design goal, set in stone before anything else. It was actually my next thought after deciding to come up with a design at all. Why? Because it would act as a forcing function, pushing me to come up with something unique. LED matrices are everywhere. I wanted to avoid the cookie-cutter pixel grid and make something that didn’t look like anyone else’s board.&lt;&#x2F;p&gt;
&lt;p&gt;The 2022 Supercon Badge was a big inspiration here—even though it does use a matrix for some LEDs. What I admired about it was how the LEDs represented meaningful state in a simulated 4-bit CPU, rather than just acting as generic pixels. That concept stuck with me.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;aesthetics-gameplay&quot;&gt;Aesthetics &amp;gt; Gameplay&lt;&#x2F;h3&gt;
&lt;p&gt;One natural consequence of avoiding a matrix was that the layout of tracks and platforms on the board would be fixed. That meant less potential for gameplay depth or variability. So I made a conscious decision early on to prioritize the board’s aesthetic appeal over its gameplay mechanics.&lt;&#x2F;p&gt;
&lt;p&gt;In other words, I chose form over function—and I leaned into that choice when I was doubting myself. Even with the limitations of a “fixed” board, I remembered how much fun I had with Tiger handheld games as a kid. Those were incredibly limited, using static LCD displays with static graphics, and yet still managed to be enjoyable and have foundational memories from them. So I felt confident that I could conceive of some enjoyable gameplay ideas despite the constraints.&lt;&#x2F;p&gt;
&lt;p&gt;Without this design goal clearly in mind, I probably would’ve struggled with the lack of gameplay flexibility. But every time that doubt crept in, I reminded myself that this tradeoff was intentional—and core to the vision.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;learning-not-earning&quot;&gt;Learning, Not Earning&lt;&#x2F;h3&gt;
&lt;p&gt;As much as I’ve always wanted to design my own hardware badge, I’ve also been drawn to the idea of creating products to sell as a fun hobby—like so many do on Tindie, Etsy, or eBay. But I also know myself: I have a tendency to get ahead of things and try to do too much at once. I realized early on that I needed to give myself the space to learn—not just chase the idea of building something sellable.&lt;&#x2F;p&gt;
&lt;p&gt;So while this project might eventually become a step toward hobbyist product design, I made sure it was not the focus. I made a deliberate choice to prioritize learning and experience over productization. (Refer back to the hardware wallet tangent that nearly derailed the design!) If I hadn’t made that design choice, my attention would’ve been split, and I doubt I would’ve finished the project with the same clarity—or satisfaction.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;choosing-the-hardware&quot;&gt;Choosing the Hardware&lt;&#x2F;h2&gt;
&lt;p&gt;I leaned heavily on my recent experience from smaller projects where I played around with different dev boards and Stemma QT&#x2F;Qwiic breakouts, testing various types of LED matrices and arrangements. That hands-on exploration really helped me develop a sense for what I liked—and what I didn’t.&lt;&#x2F;p&gt;
&lt;p&gt;One of the earliest decisions I made was to avoid Neopixels. From my previous experiments, I found them finnicky to work with at low brightness levels, and they tend to draw more baseline current than standard LEDs. They’re also more expensive and I was worried about not being able to repair them by hand. But the biggest reason just comes down to visual aethetics--they look harsh (at least to a dark-mode diehard like me)! I like them most tolerable behind diffusers, which certainly was not something i was going to consider for my project.&lt;&#x2F;p&gt;
&lt;p&gt;IS31FL3731 + LEDs: These ended up being a straightforward design choice for me. I had a good experience working with it in the Adafruit LED backpack, where I found it very easy to do smooth animations with full individial PWM control for each LED. I considered similar chips like the IS31FL3741 that could control more LEDs, but thought that 144 LEDs was a good number. Red and yellow were the natural choices for two basic warm colors with maximum contrast.&lt;&#x2F;p&gt;
&lt;p&gt;Kingbright 7 Segments + AS1115: I chose the Kingbrights because they are smol and fit well in the board aesthetic of &quot;components are buildings&quot;. There&#x27;s no specific design decision with the AS1115, I just found a IC driver for seven segments that communicated over I2C and had an inline package that fit well.&lt;&#x2F;p&gt;
&lt;p&gt;ATMega32u4: I chose this primarily because it&#x27;s a commonly used AVR chip in other designs and it has built-in USB. I had actually never used this chip before, but have experience with other AVR chips, so the USB capability felt like a useful bonus for debugging or future features. Plus, it would make it way easier to let friends or family reprogram the boards—I could just give them a script and skip the need for a separate USB-to-serial chip.  But it&#x27;s pretty expensive for what it is, ~$5&#x2F;chip, so I definitely wouldn&#x27;t have chosen this without the learning design goal.&lt;&#x2F;p&gt;
&lt;p&gt;Power Circuitry: I pieced this together mostly by reviewing schematics from other dev boards and similar projects.  I did some fairly hand-wavy math for my expected maximum current draw for my board, and made sure the LDO regulator could source well above that.&lt;&#x2F;p&gt;
&lt;p&gt;Buzzer: I used the same piezo buzzer that comes with the ACK1 coding kit hardware. The biggest factor in choosing it was how well it fit into both an empty space on the board as well into the design concept of &quot;chips are buildings&quot;. It’s relatively large for a piezo, but simple enough to drive directly from a microcontroller pin.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;layout&quot;&gt;Layout&lt;&#x2F;h2&gt;
&lt;p&gt;Layout was definitely where I spent the bulk of my time. I started by roughly laying out the LEDs to form the outer loop of the track. Then, I drew the board&#x27;s outline&#x2F;edge cuts. KiCad’s raytracer was super helpful here to give me a good visual sense of the LED spacing and adjust the overall proportion&#x2F;margins. I also found some similar sized flat objects that were roughly the same size as the board&#x27;s external dimensions and held them up to my monitor to get another perspective for how the board might look and feel in-hand. With the outer loop in place, I used my original notebook sketch as a rough guide to lay out the inner tracks and forks. Once that basic track layout was drafted, I was happy to see I still had plenty of LEDs left over for the platforms, which I added in groups to each section of track.&lt;&#x2F;p&gt;

&lt;a href=&quot;&#x2F;light-rail&#x2F;lego_track.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;lego_track.989bc491afe545ba.jpg&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;float:right;;
           margin:0.5rem;&quot;
        alt=&quot;Example Lego track with lots of 3D-printed forks and intersections. Unsuspecting, but also uncaring, cat unaware of train fast approaching.&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
&lt;p&gt;From there, I leaned on my experience designing wildly impractical Lego train track layouts (see image) to tweak a few key parameters:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Length of track sections between forks&#x2F;crosses&lt;&#x2F;li&gt;
&lt;li&gt;Direction of forks along a given track&lt;&#x2F;li&gt;
&lt;li&gt;Platform distribution in each track section, relative to length of section&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Once the track layout felt right, I moved onto the rest of the components. I put the ATMega near the bottom to keep it close to the power circuit and USB connector. The IS31FL3731 went right in the middle of the board to minimize trace length to the LEDs. At the top, I placed the Kingbright seven-segment displays and AS1115—these would serve as the  game status&#x2F;score display. Buttons were placed next to each fork and cross to function as toggles, and I added four control buttons at the bottom for gameplay input.&lt;&#x2F;p&gt;
&lt;p&gt;Before I started routing traces, I was pretty sure I’d need a 4-layer board due to trace complexity of routing to all of the LEDs. So, I began by defining the two inner layers as power and ground fills. This effectively created a large parallel-plate capacitor out of the board itself. This would help, at least in theory, with voltage stability across the board, where it would complement the existing ceramic capacitors on the board. (Mental note: at some point I&#x27;d like to run the number to get an estimate of the actual capacitance based on board area, copper thickness, and layer spacing—just to see how much it actually contributes.)&lt;&#x2F;p&gt;
&lt;p&gt;The IS31FL3731 drives its 144 LEDs as two separate 9×8 matrices, so I made sure to group the LEDs accordingly during layout. But after routing the top section, I wasn’t happy with the result. The trace paths felt unbalanced, and while PWM operates in the relatively chill kHz range, I still didn’t want to deal with potential weirdness from trace capacitance variations. So I reworked the layout, treating it more like a logic puzzle where the goal was to minimize overall trace length&#x2F;count by repositioning LEDs to better group common anodes and cathodes.&lt;&#x2F;p&gt;
&lt;p&gt;I tried an autorouter partway through the process and left it on overnight. That&#x27;s about all I have to say about the autorouter.&lt;&#x2F;p&gt;
&lt;p&gt;Meanwhile, KiCad had its own set of small annoyances. For instance, I tried saving a few traces by connecting ground to just one pad on a button footprint (since the others were internally connected), but KiCad wasn&#x27;t having it. As far as I can tell, there&#x27;s no clean way to define implicit connections within a footprint that’ll keep the design rule checker happy—at least not without resorting to something that feels even more hacky than just editing the footprint itself to satisfy the DRC.&lt;&#x2F;p&gt;
&lt;p&gt;Once layout was done, I spent way too much time drawing silkscreen roads and tiny parking spots. For how small they are, I obsessed a bit too much over getting consistent widths and spacing. But I thought turned out great, my artistic skill notwithstanding, so... only minor regrets there. When I showed my mockups to my family, I immediately got comments about how the components looked like buildings. Instant validation.&lt;&#x2F;p&gt;
&lt;br&#x2F;&gt;
&lt;h1 id=&quot;ordering-manufacturing-assembly&quot;&gt;Ordering, Manufacturing, Assembly&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;order-preparation&quot;&gt;Order Preparation&lt;&#x2F;h2&gt;
&lt;p&gt;Before this project, I had only done one other project that used PCBs of my own design—my Stemmett project—so I had pretty limited experience with the various options for PCB manufacturing and assembly. Luckily, early in the design process, PCBWay reached out to me about a potential collaboration. Since I hadn’t tried their services before, it made the choice of manufacturer really easy! Looking back, I genuinely don’t have any real issues worth mentioning—just good things to say about the whole experience.&lt;&#x2F;p&gt;
&lt;p&gt;Getting started with the ordering process was super smooth, thanks to PCBWay’s KiCad integration. They have a plugin you can install directly from KiCad’s plugin manager, which adds a menu option that opens your browser and pre-fills their ordering form with your Gerbers. That alone saved me a bunch of time and clicks throughout my design iterations compared to my last project.&lt;&#x2F;p&gt;
&lt;p&gt;I also decided early on to go with full assembly for the boards. This freed me up during the design process to focus more on aesthetics instead of worrying about the complexity or hand-assembly viability of each part. Plus, I knew going through the assembly experience would be valuable for future projects. While I don’t have other services to compare it to, my experience with PCBWay’s assembly was smooth and pretty painless overall.&lt;&#x2F;p&gt;
&lt;p&gt;The most time-consuming part of the assembly order process was preparing the Bill of Materials (BoM). I did this manually using PCBWay’s BoM sample template as a guide, which was really helpful. KiCad has some ability to generate BoMs, but I decided—at least for my first time—to raw dog it. It was a crash course in datasheet spelunking: making sure I had the exact manufacturer part numbers, learning the myriad SMD package types (and all the weird naming overlaps), and double-checking all the tiny details. I ended up relying heavily on Digikey’s product pages for this, since I found their descriptions and data formatting to be much more consistent than Mouser’s.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ordering-and-assembly-with-pcbway&quot;&gt;Ordering and Assembly With PCBWay&lt;&#x2F;h2&gt;
&lt;p&gt;Once I finished the BoM, I could submit the order. Unfortunately, I realized soon after hitting submit that I had uploaded the wrong version of the BoM. But to my relief, I was able to get in touch with customer service almost immediately through a live chat window on the order page—ostensibly human as well (though you can never be sure now). They addressed my concerns quickly and let me know I could just email my assigned rep directly with the updated file.&lt;&#x2F;p&gt;
&lt;p&gt;After submitting the order, I spent the next few days working out a few kinks in my layout through some back-and-forth with the review team. The main issue was that the minimum solder mask bridge width for the black solder mask was slightly less forgiving than the standard green. That meant a couple of the ICs on the board had pin gaps too narrow for the solder mask to &quot;bridge&quot; between them. The fix was simple: just remove the solder mask between the pins. I was initially concerned this might increase the risk of solder bridging or shorts, but after a bit of reading, I found that it’s actually not that uncommon—especially when the chips aren’t being hand-soldered. Since I wasn’t planning to assemble the boards myself, I felt comfortable with the change.&lt;&#x2F;p&gt;
&lt;div class=&quot;justify-center not-prose flex flex-wrap gap-2&quot;&gt;
  
&lt;a href=&quot;&#x2F;light-rail&#x2F;solder_mask_gap.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;solder_mask_gap.cd7b2da7ff85d3ac.png&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;;
           margin:0.5rem;&quot;
        alt=&quot;Showing pin gap distance of ~0.2mm&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
  
&lt;a href=&quot;&#x2F;light-rail&#x2F;solder_mask.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;solder_mask.05937ef928a11f61.png&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;;
           margin:0.5rem;&quot;
        alt=&quot;Showing solder mask bridging gap&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
  
&lt;a href=&quot;&#x2F;light-rail&#x2F;solder_mask_exclusion.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;solder_mask_exclusion.30d307d8b7d66dbc.png&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;;
           margin:0.5rem;&quot;
        alt=&quot;Showing manually drawn exclusion zone to prevent solder mask bridging&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;The reason it took a few rounds to get right, though, was mostly due to my struggles with getting KiCad to actually apply the fix. On my first attempt, I found the “Solder mask minimum web width” setting under the solder mask&#x2F;paste options in the layout editor. The tooltip said, “Min. dist between two pad areas. Two pads nearer this area will be merged during plotting.” That sounded exactly like what I needed. The default was 0, so I changed it to PCBWay’s requirement for the black solder mask (0.22mm), shot back the Gerbers, and called it a day—without actually checking if it had worked. (It didn’t do anything). For the second attempt, I spent way too long fiddling with settings trying to get KiCad to just fill in the gaps between pads like I expected. Eventually I gave up and manually drew solder mask exclusion zones around the pads—it took about two minutes as opposed to maybe an hour or two struggling to figure out KiCad settings. I sent the updated files back to PCBWay, only to realize later I’d completely forgotten to apply the same fix to the other IC that had the same issue. So: one last revision and my board layout finally passed review.&lt;&#x2F;p&gt;
&lt;p&gt;After resolving the board layout issue, the next step was getting everything squared away for assembly. This was my first time going through an assembly process, so I was prepared for unforeseen issues. But overall, the experience with PCBWay ended up being much smoother than I anticipated. As part of the initial order prep, I sent them a couple of near-final BoMs, and they sent back an updated version with quotes for the parts. I had opted for PCBWay’s turnkey assembly, where they source all the components themselves. Since it was my first time and I had no strong expectations, so I was pleasantly surprised to see that most of their component quotes were either cheaper than or on par with what I’d pay ordering directly from Mouser or DigiKey. The bigger surprise, though, was just how fast the total cost of components per board added up! My first instinct was to dive headfirst into cost-optimization mode (the ATmega was immediately on the chopping block), but I reeled myself back in by remembering my design goal: learning, not earning. Phew.&lt;&#x2F;p&gt;
&lt;p&gt;That said, the process wasn’t without hiccups. There was a roughly two-week delay where I was unknowingly holding things up. PCBWay had sent some engineering questions via email, but I completely missed them. I had been checking my order daily on their website, where there is a tab for engineering questions, and had not seen any indication. This is definitely my biggest piece of feedback for PCBway if they are reading! Please make sure engineering questions sent via email also show up in the website’s order dashboard! The engineering questions themselves were straightforward. They needed an extra reference image for the LED orientation and clarification that components I had marked &quot;DNA&quot; in the BoM did not need any solder mask (which was frivolous given the DNA marker, right?). A couple of assembly-related issues also cropped up. One was entirely my fault: I made the mistake of swapping out the reset switch in the schematic and BoM, but I had forgotten to also update the footprint so it wouldn&#x27;t work on the boards that had already been manufactured at that point. Fortunately, the fix was easy! I found a switch that matched the footprint and PCBWay was able to sourced the new part, for the same price, and it only delayed the assembly process one day!&lt;&#x2F;p&gt;
&lt;p&gt;The other issue was that the footprints of all the other buttons on the board did not match the footprint of the actual buttons, oof. But in this case, it was entirely out of my purview or control because the buttons didn’t match their own &lt;a href=&quot;https:&#x2F;&#x2F;www.ckswitches.com&#x2F;media&#x2F;2780&#x2F;pts526.pdf&quot;&gt;datasheet&lt;&#x2F;a&gt;. PCBWay also pointed this out with a screenshot of the datasheet and photo of the buttons. Thankfully, the mismatch only affected the positioning of the ground pins, so the buttons were still solderable and fully functional.&lt;&#x2F;p&gt;
&lt;div class=&quot;justify-center not-prose flex flex-wrap gap-2&quot;&gt;
  
&lt;a href=&quot;&#x2F;light-rail&#x2F;button_footprint_datasheet.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;button_footprint_datasheet.b1b4ab1557e60d1e.png&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;;
           margin:0.5rem;&quot;
        alt=&quot;Datasheet specification for button footprint. Ground pins are symmetrical and aligned with long axis of other pins&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
  
&lt;a href=&quot;&#x2F;light-rail&#x2F;button_footprint_actual.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img
        src=&quot;https:&amp;#x2F;&amp;#x2F;altonimb.us&amp;#x2F;processed_images&amp;#x2F;button_footprint_actual.ffae749e5f9e45fa.jpg&quot;
        class=&quot;rounded-lg&quot;
        style=&quot;;
           margin:0.5rem;&quot;
        alt=&quot;Photo of actual buttons. Ground pins are mutally offset and aligned with short axist of other pins&quot; &#x2F;&gt;
&lt;&#x2F;a&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;About a week after clearing up the engineering questions, I got an email with annotated photos of an assembled board. PCBWay wanted me to confirm the LED and seven-segment display orientations. The LEDs were good, but I spotted that the seven-segments were upside down. After responding, I got another email with new photos the very next day showing the board with the corrections, and I gave the thumbs-up to assemble the rest. Four days later, the boards shipped! When they arrived, they were nearly perfect! The only asssembly issue was that component C1 was missing on every board. Ironically, however, due to my own design issue, the component C1 ended up being unnecessary.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;design-issues&quot;&gt;Design Issues&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;clock-source&quot;&gt;Clock Source&lt;&#x2F;h2&gt;
&lt;p&gt;I didn’t select a clock source until fairly late in the design process. I had placed a placeholder symbol and footprint in the schematic and only swapped in a CMOS oscillator near the end, when I was focused on wrapping up the layout. Unfortunately, I only glanced at the pin mapping table in the datasheet—and skipped the rest. That oversight caused the ATmega chips to be completely non-functional when the boards arrived. I had ordered the SKU with default fuses set for an external clock, but due to my mistake, the MCU had no stable clock source. Worse, I couldn’t even get an ISP programmer to recongize the chip so I could read and update the fuses! Thankfully, after a few hours of debugging, I was able to fully diagnose and resolve the issue.&lt;&#x2F;p&gt;
&lt;p&gt;After digging back into the datasheets for the ATmega and the oscillator, and doing a little research into the differences between passive crystals (XTAL) and active oscillators (XO), the issue, and my mistake, become known. When the ATmega fuses are configured for a crystal oscillator, both the XTAL1 and XTAL2 pins are used as part of the whole oscillator circuit. That means XTAL2 is not stable during normal operation. But in my schematic, when I had replaced the crystal with an active oscillator, I had left XTAL2 connected to the oscillator’s tri-state pin, where I unknowly made the assumption that the pin functionality was the same. When I read the oscillator datasheet again, this time thoroughly, I realized that I had left the oscillator&#x27;s tri-state (minor gripe that it didn&#x27;t say enable pin) pin on a non-stable input--an invalid state for the oscillator to be in.&lt;&#x2F;p&gt;
&lt;p&gt;My first workaround was a literal glob of solder between the XO&#x27;s enable pin and the adjacent VCC pin. That kept the oscillator always on, and finally let me communicate with the ATmega with an ISP programmer. Later, I built a pogo pin jig that I could press down carefully on the board to temporarily short those same pins during programming. That allowed me to update the fuses to use an external oscillator (not a crystal), which disables the internal oscillator circuit and frees up XTAL2 as a GPIO. Once the fuses were updated, XTAL2, as a GPIO, then defaulted to a floating&#x2F;high-impedance state. Since I had carefully read the oscillator spec, I knew that leaving the enable pin floating was a valid &quot;enable&quot; state, and the oscillator could function with no solder or jigs required.&lt;&#x2F;p&gt;
&lt;p&gt;After that change, I plugged the board into my computer via USB—and boom, the stock DFU bootloader showed up in Windows Device Manager! Good feels.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;usb-usb-bootloader-issue&quot;&gt;USB&#x2F;USB Bootloader issue&lt;&#x2F;h2&gt;
&lt;p&gt;Once I had the DFU bootloader showing up over USB, I wanted to try using the Caterina bootloader. This is the &quot;standard&quot; USB bootloader found on many Arduino-family ATmega32u4-based boards like the Leonardo, Adafruit Feather 32u4, or SparkFun Pro Micro. Unfortunately, after flashing th Caterina bootloader, things stopped progressing. No variation I tried worked—each time I plugged the board in, Windows reported it as a non-functional USB device.&lt;&#x2F;p&gt;
&lt;p&gt;It was frustrating: the stock DFU bootloader showed up fine, so why not Caterina? After a bunch of head-scratching, I decided to re-flash the stock DFU bootloader to sanity-check my hardware and try flashing via DFU. Weirdly, I had to dig up the original DFU bootloader binary from some GitHub repo—I couldn’t find any official download from Microchip. I supposed I could have also read the flash data from one of the boards that still had it. Thankfully for my sanity, reflashing the DFU bootloader worked. The boards showed up again in Device Manager, and I was subsequently able to easily flash a firmware hex using dfu-programmer and see my code running on the boards!&lt;&#x2F;p&gt;
&lt;p&gt;At that point, I decided to shelve the Caterina investigation and move on. There didn’t seem to be much benefit in spending more time chasing down the issue when I already had a working toolchain for flashing code. My current theory is that the Caterina bootloader negotiates a faster USB bus speed than the DFU bootloader and is hitting some kind of timing issue—possibly due to clock instability or something subtle in my board layout. It could also be a USB signal integrity problem—maybe the impedance isn’t quite right, and tweaking the resistor values on D+&#x2F;D− could help. Since I don’t know much about USB internals yet, and digging further would require a decent amount of ramp-up time, I was fine leaving it alone for now.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion-and-next-steps&quot;&gt;Conclusion and Next Steps&lt;&#x2F;h1&gt;
&lt;p&gt;All in all, I’m really happy with how this project turned out. I learned a ton and got exactly the kind of hands-on experience I was hoping for—especially when it came to debugging and coming up with workarounds and fixes for design issues. I’m thankful that the problems I ran into weren’t insurmountable. Some of that was luck, sure, but a lot of it came down to taking my time, reviewing the design carefully, and coming back to it repeatedly with fresh eyes instead of rushing to place the order.&lt;&#x2F;p&gt;
&lt;p&gt;The mistakes I did make mostly revealed gaps in my review process. For example, I read the datasheets for the driver ICs over and over, yet somehow never gave the two-page oscillator datasheet a proper read. On the other hand, I could’ve pored over the button datasheet countless times and still not predicted that the components wouldn’t match spec (who does that!?!?). That contrast really drove home an important point: you can’t plan for everything—but that doesn’t let you off the hook for due diligence. The key is focusing your energy on the parts of the process you can control, and being ready to adapt when the unexpected inevitably shows up.&lt;&#x2F;p&gt;
&lt;p&gt;That wraps up the first half of the write-up! I made an interesting decision midway through this project: after submitting the order and while production was underway, I decided to implement all of the firmware in Rust. I’d “learned” Rust a few times before, but I didn’t speak it—because I’d never actually used it to build anything, so none of it really stuck. Well, I can say now that I’m a convert. Learning Rust—even if I never use it again—has made me a better C++ programmer, and a better programmer in general. The second half of this write-up will be about that journey.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
